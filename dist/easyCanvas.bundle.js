/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./easyCanvas.ts":
/*!***********************!*\
  !*** ./easyCanvas.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EasyCanvas: () => (/* binding */ EasyCanvas)\n/* harmony export */ });\n/* harmony import */ var _easyCanvasHotAndReady__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./easyCanvasHotAndReady */ \"./easyCanvasHotAndReady.ts\");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers */ \"./helpers.ts\");\n\n\n\n// d for domain, r for range...actually affine.\nfunction linearScale(d1, d2, r1, r2) {\n    function scale(x) {\n        let z = (x - d1) / (d2 - d1);\n        return z * (r2 - r1) + r1;\n    }\n    return scale;\n}\n// For mobile zooming / panning\nfunction getScalesFromPoints(oldPoints, newPoints) {\n    let distOld = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.dist)(...oldPoints);\n    let distNew = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.dist)(...newPoints);\n    let s = distNew / distOld;\n    let sx = s;\n    let sy = s;\n    let oldMidX = (oldPoints[0].x + oldPoints[1].x) / 2;\n    let oldMidY = (oldPoints[0].y + oldPoints[1].y) / 2;\n    let newMidX = (newPoints[0].x + newPoints[1].x) / 2;\n    let newMidY = (newPoints[0].y + newPoints[1].y) / 2;\n    // scaling only along y-axis\n    if (oldPoints[0].x < this.xmin && oldPoints[1].x < this.xmin) {\n        sx = 1;\n        newMidX = oldMidX;\n    }\n    // scaling only along x-axis\n    if (oldPoints[0].y < this.ymin && oldPoints[1].y < this.ymin) {\n        sy = 1;\n        newMidY = oldMidY;\n    }\n    let scaleX = linearScale(newMidX, newMidX + sx, oldMidX, oldMidX + 1);\n    let scaleY = linearScale(newMidY, newMidY + sy, oldMidY, oldMidY + 1);\n    return [scaleX, scaleY];\n}\nclass EasyCanvas extends HTMLElement {\n    shadow;\n    canvas;\n    panningControl;\n    zoomingControl;\n    ctx;\n    // Constantly adjust DPI with possibly changing screen size\n    DPIHasBeenSet = false;\n    dpiInterval;\n    // config\n    framerate = 30;\n    xpadding = 10;\n    ypadding = 16;\n    xmin = -100;\n    xmax = 100;\n    ymin = -100;\n    ymax = 100;\n    dpr = 2; // device pixel ratio.\n    debug = true;\n    defaultAxesOn = true;\n    mouseDown = false; // left mouse button is not clicked in when the webpage loads...\n    fontsize = 25;\n    hotAndReady;\n    hotAndReadyEventListeners;\n    oldScales;\n    scaleX;\n    scaleY;\n    scaleXInverse;\n    scaleYInverse;\n    oldxmin;\n    oldxmax;\n    oldymin;\n    oldymax;\n    linkedKeys;\n    link;\n    lastFrame;\n    mouseX;\n    mouseY;\n    drawingLoop;\n    static get observedAttributes() {\n        return [\n            \"xmin\",\n            \"xmax\",\n            \"ymin\",\n            \"ymax\",\n            \"framerate\",\n            \"xpadding\",\n            \"ypadding\",\n            \"default-axes-on\",\n            \"controls\",\n            \"fontsize\"\n        ];\n    }\n    constructor() {\n        // Always call super first in constructor\n        super();\n        // Set up canvas \n        this.shadow = this.attachShadow({ mode: 'open' });\n        this.canvas = document.createElement(\"canvas\");\n        this.canvas.setAttribute(\"style\", \"border:1px solid black;width:100%;height:100%;\");\n        // update this.mouseDown boolean\n        this.canvas.addEventListener(\"mousedown\", function (e) { this.mouseDown = true; }.bind(this));\n        this.canvas.addEventListener(\"mouseup\", function (e) { this.mouseDown = false; }.bind(this));\n        // update mouseX and mouseY locations\n        this.canvas.addEventListener(\"mousemove\", function (e) {\n            // get size of padding in data units.\n            let padXPixels = (this.xpadding / 100) * this.canvas.width;\n            let padYPixels = (this.ypadding / 100) * this.canvas.height;\n            // data coordinates of actual canvas boundary.\n            let px = Math.abs(this.scaleXInverse(padXPixels) - this.scaleXInverse(0));\n            let py = Math.abs(this.scaleYInverse(padYPixels) - this.scaleYInverse(0));\n            this.mouseX = this.scaleXInverse(e.offsetX * this.dpr);\n            this.mouseY = this.scaleYInverse(e.offsetY * this.dpr);\n        }.bind(this));\n        this.canvas.addEventListener(\"mouseleave\", function (e) {\n            this.mouseDown = false;\n            this.mouseX = undefined;\n            this.mouseY = undefined;\n        }.bind(this));\n        // panningControl and zoomingControl can't be actual methods because they need\n        // to be bound to the object for event handling.\n        this.panningControl = function (e) {\n            if (this.mouseDown) {\n                let dx = this.scaleXInverse(e.movementX) - this.scaleXInverse(0);\n                let dy = this.scaleYInverse(e.movementY) - this.scaleYInverse(0);\n                dx *= this.dpr;\n                dy *= this.dpr;\n                this.xmin -= dx;\n                this.xmax -= dx;\n                this.ymin -= dy;\n                this.ymax -= dy;\n                this.renderPlot();\n            }\n        }.bind(this);\n        this.zoomingControl = function (e) {\n            let xdist = this.xmax - this.xmin;\n            let ydist = this.ymax - this.ymin;\n            let sensitivity = 0.001;\n            let zoomAmount = (e.deltaY * sensitivity);\n            let px = (this.mouseX - this.xmin) / xdist;\n            let py = (this.mouseY - this.ymin) / ydist;\n            // make sure the zoom makes sense and there aren't weird numerical issues.\n            // also make sure we don't zoom in too far...\n            if (isNaN(px) || isNaN(py) || isNaN(zoomAmount) ||\n                (zoomAmount < 0 && Math.abs(zoomAmount) < 0.000001)) {\n                return;\n            }\n            let aspectRatio = xdist / ydist;\n            if (this.mouseX > this.xmin && this.mouseY > this.ymin) {\n                zoomAmount *= Math.max(xdist, ydist);\n                this.xmin -= px * zoomAmount;\n                this.xmax += (1 - px) * zoomAmount;\n                this.ymin -= py * zoomAmount / aspectRatio;\n                this.ymax += (1 - py) * zoomAmount / aspectRatio;\n            }\n            else if (this.mouseY < this.ymin) {\n                zoomAmount *= xdist;\n                this.xmin -= px * zoomAmount;\n                this.xmax += (1 - px) * zoomAmount;\n            }\n            else if (this.mouseX < this.xmin) {\n                zoomAmount *= ydist;\n                this.ymin -= py * zoomAmount;\n                this.ymax += (1 - py) * zoomAmount;\n            }\n            e.preventDefault();\n            this.renderPlot();\n        }.bind(this);\n        // panning controls\n        this.canvas.addEventListener(\"mousemove\", this.panningControl);\n        // zooming controls\n        this.canvas.addEventListener(\"wheel\", this.zoomingControl);\n        // touch events:\n        this.canvas.addEventListener(\"touchstart\", function (e) {\n            if (e.touches.length == 2) {\n                this.twoFingerStartEvent = e;\n                this.saveScalesAndRanges();\n                e.preventDefault();\n            }\n        }.bind(this));\n        this.canvas.addEventListener(\"touchmove\", function (e) {\n            if (e.touches.length == 2) {\n                // Get old and new touch positions\n                let { pageX: x1Old, pageY: y1Old } = this.twoFingerStartEvent.touches[0];\n                let { pageX: x2Old, pageY: y2Old } = this.twoFingerStartEvent.touches[1];\n                let { pageX: x1New, pageY: y1New } = e.touches[0];\n                let { pageX: x2New, pageY: y2New } = e.touches[1];\n                // some quick defines to make the next bit more concise.\n                let [sxi, syi] = [this.oldScales[\"scaleXInverse\"], this.oldScales[\"scaleYInverse\"]];\n                let dpr = this.dpr;\n                let left = this.canvas.offsetLeft;\n                let top = this.canvas.offsetTop;\n                // Rescale old and new touch positions\n                let oldPoints = [\n                    { x: sxi((x1Old - left) * dpr), y: syi((y1Old - top) * dpr) },\n                    { x: sxi((x2Old - left) * dpr), y: syi((y2Old - top) * dpr) }\n                ];\n                let newPoints = [\n                    { x: sxi((x1New - left) * dpr), y: syi((y1New - top) * dpr) },\n                    { x: sxi((x2New - left) * dpr), y: syi((y2New - top) * dpr) }\n                ];\n                let [pinchScaleX, pinchScaleY] = getScalesFromPoints.bind(this)(oldPoints, newPoints);\n                this.setAttribute(\"xmin\", pinchScaleX(this.oldxmin));\n                this.setAttribute(\"xmax\", pinchScaleX(this.oldxmax));\n                this.setAttribute(\"ymin\", pinchScaleY(this.oldymin));\n                this.setAttribute(\"ymax\", pinchScaleY(this.oldymax));\n                this.renderPlot();\n                e.preventDefault();\n            }\n        }.bind(this));\n        this.canvas.addEventListener(\"touchend\", function (e) {\n            if (e.touches.length == 2) {\n                this.twoFingerStartEvent = e;\n            }\n        }.bind(this));\n        this.shadow.appendChild(this.canvas);\n        this.ctx = this.canvas.getContext(\"2d\");\n        // Constantly adjust DPI with possibly changing screen size\n        this.dpiInterval = setInterval(this.fixDPI.bind(this), 500);\n        window.addEventListener(\"load\", this.fixDPI.bind(this));\n        this.updateScales();\n        // bind all methods from easyCanvasHotAndReady\n        this.hotAndReady = {};\n        for (let key of Object.keys(_easyCanvasHotAndReady__WEBPACK_IMPORTED_MODULE_0__)) {\n            this.hotAndReady[key] = _easyCanvasHotAndReady__WEBPACK_IMPORTED_MODULE_0__[key].bind(this);\n        }\n        this.hotAndReadyEventListeners = {};\n        // Constantly be redrawing the plot at this.framerate\n        this.renderPlotLoop();\n    }\n    saveScalesAndRanges() {\n        this.oldScales = {\n            scaleX: this.scaleX,\n            scaleY: this.scaleY,\n            scaleXInverse: this.scaleXInverse,\n            scaleYInverse: this.scaleYInverse\n        };\n        this.oldxmin = this.xmin;\n        this.oldxmax = this.xmax;\n        this.oldymin = this.ymin;\n        this.oldymax = this.ymax;\n    }\n    attributeChangedCallback(name, oldValue, newValue) {\n        if (this.debug)\n            console.log(`custom element attribute \"${name}\" has changed from \"${oldValue}\" to \"${newValue}\"`);\n        // simple numeric\n        if ([\"xmin\", \"xmax\", \"ymin\", \"ymax\", \"xpadding\", \"ypadding\", \"framerate\", \"fontsize\"].includes(name)) {\n            this[name] = +newValue;\n            this.updateScales();\n        }\n        // simple boolean\n        else if ([\"default-axes-on\"].includes(name)) {\n            this.defaultAxesOn = (newValue == \"true\");\n        }\n        else if (name === \"controls\") {\n            this.canvas.removeEventListener(\"mousemove\", this.panningControl);\n            this.canvas.removeEventListener(\"wheel\", this.zoomingControl);\n            if (newValue.toLowerCase() === \"true\") {\n                this.canvas.addEventListener(\"mousemove\", this.panningControl);\n                this.canvas.addEventListener(\"wheel\", this.zoomingControl);\n            }\n        }\n    }\n    updateScales() {\n        let w = this.canvas.width;\n        let h = this.canvas.height;\n        let padXPixels = (this.xpadding / 100) * w;\n        let padYPixels = (this.ypadding / 100) * h;\n        // map the range of the data to the range of the canvas where data should appear.\n        this.scaleX = linearScale(this.xmin, this.xmax, padXPixels, w - padXPixels);\n        this.scaleY = linearScale(this.ymin, this.ymax, h - padYPixels, padYPixels);\n        this.scaleXInverse = linearScale(padXPixels, w - padXPixels, this.xmin, this.xmax);\n        this.scaleYInverse = linearScale(h - padYPixels, padYPixels, this.ymin, this.ymax);\n    }\n    fixDPI() {\n        //the + prefix casts it to an integer\n        //the slice method gets rid of \"px\"\n        let s = getComputedStyle(this.canvas);\n        let style_height = +s.getPropertyValue(\"height\").slice(0, -2);\n        let style_width = +s.getPropertyValue(\"width\").slice(0, -2);\n        //scale the canvas\n        let heightDiff = Math.abs(this.canvas.height - style_height * this.dpr);\n        let widthDiff = Math.abs(this.canvas.width - style_width * this.dpr);\n        // don't need to update canvas height or width unless they have changed significantly recently\n        if (Math.max(heightDiff, widthDiff) > 10) {\n            this.canvas.height = style_height * this.dpr;\n            this.canvas.width = style_width * this.dpr;\n            this.DPIHasBeenSet = true;\n        }\n        this.renderPlot();\n    }\n    linkInfo(keys, link) {\n        this.linkedKeys = keys;\n        this.link = link;\n    }\n    renderPlotLoop() {\n        // will be true if this.lastFrame is undefined\n        let ready = (new Date().getTime() - this.lastFrame > 1000 / this.framerate);\n        ready = (ready || this.lastFrame === undefined);\n        try {\n            if (ready) {\n                this.renderPlot();\n            }\n        }\n        catch (e) {\n            console.error(e);\n        }\n        finally {\n            requestAnimationFrame(this.renderPlotLoop.bind(this));\n        }\n    }\n    renderPlot() {\n        // linked axes and other info maybe...\n        if (this.DPIHasBeenSet) {\n            if (this.link !== undefined) {\n                for (let key of this.linkedKeys) {\n                    if (this.link[key] !== undefined && this.mouseX === undefined) {\n                        this.setAttribute(key, this.link[key]);\n                    }\n                }\n            }\n            this.updateScales();\n            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n            this.ctx.beginPath(); // clears any old path they may have made.\n            if (this.drawingLoop) {\n                this.drawingLoop();\n            }\n            // this needs to be below the drawing loop because \n            // your drawing loop may disable the default axes. (hotAndReady does)\n            if (this.defaultAxesOn) {\n                this.drawDefaultAxes();\n            }\n            // linked axes and other info maybe...\n            if (this.link !== undefined) {\n                for (let key of this.linkedKeys) {\n                    if (this.mouseX !== undefined) {\n                        this.link[key] = this[key];\n                    }\n                }\n            }\n            this.lastFrame = new Date();\n        }\n    }\n    drawLabel(settings) {\n        settings[\"theta\"] = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.defaultVal)(settings[\"theta\"], 0);\n        settings[\"font\"] = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.defaultVal)(settings[\"font\"], \"20px Lato\");\n        settings[\"textAlign\"] = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.defaultVal)(settings[\"textAlign\"], \"left\");\n        settings[\"textBaseline\"] = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.defaultVal)(settings[\"textBaseline\"], \"alphabetic\");\n        this.ctx.save();\n        this.ctx.textBaseline = settings.textBaseline;\n        this.ctx.textAlign = settings.textAlign;\n        this.ctx.font = settings.font;\n        this.ctx.translate(settings.x, settings.y);\n        this.ctx.rotate(-settings.theta);\n        this.ctx.fillText(settings.text, 0, 0);\n        this.ctx.restore();\n    }\n    drawAxis(settings) {\n        let { x1, y1, x2, y2 } = settings;\n        let { labelXOffset, labelYOffset, labelTheta, nTicks } = settings;\n        let { labels, scaleStart, scaleEnd } = settings;\n        let { isDatetime } = settings;\n        let r = Math.sqrt(Math.pow(y2 - y1, 2) + Math.pow(x2 - x1, 2));\n        let theta = Math.asin((y2 - y1) / r);\n        this.ctx.save();\n        this.ctx.lineWidth = 2;\n        this.ctx.beginPath();\n        this.ctx.moveTo(Math.floor(this.scaleX(x1)), Math.floor(this.scaleY(y1)));\n        this.ctx.lineTo(Math.floor(this.scaleX(x2)), Math.floor(this.scaleY(y2)));\n        this.ctx.stroke();\n        for (let i = 1; i <= nTicks; i++) {\n            let x = this.scaleX(x1 + (x2 - x1) * (i / nTicks));\n            let y = this.scaleY(y1 + (y2 - y1) * (i / nTicks));\n            this.ctx.beginPath();\n            this.ctx.moveTo(x - 10 * Math.cos(theta - Math.PI / 2), y + 10 * Math.sin(theta - Math.PI / 2));\n            this.ctx.lineTo(x + 10 * Math.cos(theta - Math.PI / 2), y - 10 * Math.sin(theta - Math.PI / 2));\n            this.ctx.stroke();\n            // labelXOffset and labelYOffset are in user coordinates (not canvas coordinates)\n            let labelX = this.scaleX(this.scaleXInverse(x) + labelXOffset);\n            let labelY = this.scaleY(this.scaleYInverse(y) + labelYOffset);\n            let labelSettings = {\n                x: labelX,\n                y: labelY,\n                theta: labelTheta,\n                textAlign: \"center\",\n                font: `${this.fontsize}px Lato`\n            };\n            if (labels) {\n                labelSettings.text = labels[i - 1];\n                this.drawLabel(labelSettings);\n            }\n            else if (!isNaN(scaleStart) && !isNaN(scaleEnd)) {\n                let label;\n                if (isDatetime) {\n                    label = _helpers__WEBPACK_IMPORTED_MODULE_1__.getTimeLabel(i, nTicks, scaleStart, scaleEnd);\n                }\n                else {\n                    label = scaleStart + (scaleEnd - scaleStart) * (i / nTicks);\n                    label = label.toFixed(2);\n                }\n                labelSettings.text = label;\n                this.drawLabel(labelSettings);\n            }\n            else {\n                console.error(\"drawAxis method of EasyCanvas object must be called with 'labels' or both 'scaleStart' and 'scaleEnd'\");\n            }\n        }\n        this.ctx.restore();\n    }\n    drawDefaultAxes(settings) {\n        settings = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.defaultVal)(settings, {});\n        let [xTicks, yTicks] = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.defaultVals)(settings, [\"xTicks\", \"yTicks\"], [10, 5]);\n        let [xAxisIsTime, yAxisIsTime] = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.defaultVals)(settings, [\"xAxisIsTime\", \"yAxisIsTime\"], [false, false]);\n        // x-axis\n        let labelYOffset = this.scaleYInverse(this.fontsize + 10) - this.scaleYInverse(0);\n        this.drawAxis({\n            x1: this.xmin,\n            y1: this.ymin,\n            x2: this.xmax,\n            y2: this.ymin,\n            labelXOffset: 0,\n            labelYOffset: labelYOffset,\n            labelTheta: Math.PI / 8,\n            nTicks: xTicks,\n            labels: undefined,\n            scaleStart: this.xmin,\n            scaleEnd: this.xmax,\n            isDatetime: xAxisIsTime\n        });\n        // y-axis\n        let labelXOffset = this.scaleXInverse(-(this.fontsize + 10)) - this.scaleXInverse(0);\n        this.drawAxis({\n            x1: this.xmin,\n            y1: this.ymin,\n            x2: this.xmin,\n            y2: this.ymax,\n            labelXOffset: labelXOffset,\n            labelYOffset: 0,\n            labelTheta: Math.PI / 3,\n            nTicks: yTicks,\n            labels: undefined,\n            scaleStart: this.ymin,\n            scaleEnd: this.ymax,\n            isDatetime: yAxisIsTime\n        });\n    }\n    drawLine(data, lineWidth = 2) {\n        let xs = data.xs.map(x => this.scaleX(x));\n        let ys = data.ys.map(y => this.scaleY(y));\n        let oldLineWidth = this.ctx.lineWidth;\n        this.ctx.lineWidth = lineWidth;\n        this.ctx.beginPath();\n        this.ctx.moveTo(xs[0], ys[0]);\n        for (let i = 1; i < xs.length; i++) {\n            this.ctx.lineTo(xs[i], ys[i]);\n        }\n        this.ctx.stroke();\n        this.ctx.lineWidth = oldLineWidth;\n    }\n    // in custom coordinates, not canvas coordinates\n    mouseInCircle(cx, cy, r) {\n        if (this.mouseX === undefined || this.mouseY === undefined) {\n            return false;\n        }\n        return ((0,_helpers__WEBPACK_IMPORTED_MODULE_1__.dist)(this.mouseX, this.mouseY, cx, cy) < r);\n    }\n    // opposite corners of a rectangle.\n    mouseInRect(x1, y1, x2, y2) {\n        if (this.mouseX === undefined || this.mouseY === undefined) {\n            return false;\n        }\n        // helper function to tell if x is between a and b.\n        function between(x, a, b) {\n            return (a <= x && x <= b) || (b <= x && x <= a);\n        }\n        return (between(this.mouseX, x1, x2) && between(this.mouseY, y1, y2));\n    }\n    // standard canvas stuff wrapped or reimplemented!!\n    arc(cx, cy, r, sAngle, eAngle, counterclockwise = false) {\n        let delta = 0.05;\n        if (!counterclockwise) {\n            let tmp = sAngle;\n            sAngle = eAngle;\n            eAngle = tmp + 2 * Math.PI;\n        }\n        let x = this.scaleX(cx + Math.cos(sAngle) * r);\n        let y = this.scaleY(cy + Math.sin(sAngle) * r);\n        this.ctx.moveTo(x, y);\n        for (let angle = sAngle; angle < eAngle - delta; angle += delta) {\n            let x = this.scaleX(cx + Math.cos(angle) * r);\n            let y = this.scaleY(cy + Math.sin(angle) * r);\n            this.ctx.lineTo(x, y);\n        }\n    }\n    rect(x, y, w, h) {\n        x = this.scaleX(x);\n        y = this.scaleY(y);\n        w = this.scaleX(w) - this.scaleX(0);\n        h = this.scaleY(h) - this.scaleY(0);\n        this.ctx.moveTo(x, y);\n        this.ctx.lineTo(x, y + h);\n        this.ctx.lineTo(x + w, y + h);\n        this.ctx.lineTo(x + w, y);\n        this.ctx.lineTo(x, y);\n    }\n}\ncustomElements.define('easy-canvas', EasyCanvas);\n// hack to dynamically load css for easy-canvas...\nvar link = document.createElement('link');\nlink.setAttribute('rel', 'stylesheet');\nlink.setAttribute('type', 'text/css');\nlink.setAttribute('href', 'https://fonts.googleapis.com/css?family=Lato:100,200,300,400,500,600');\ndocument.head.appendChild(link);\n\n\n\n//# sourceURL=webpack:///./easyCanvas.ts?");

/***/ }),

/***/ "./easyCanvasHotAndReady.ts":
/*!**********************************!*\
  !*** ./easyCanvasHotAndReady.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   barPlot: () => (/* binding */ barPlot),\n/* harmony export */   drawTooltip: () => (/* binding */ drawTooltip),\n/* harmony export */   histogram: () => (/* binding */ histogram),\n/* harmony export */   linePlot: () => (/* binding */ linePlot)\n/* harmony export */ });\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers */ \"./helpers.ts\");\n/* this file contains functions for making very common plots using easyCanvas */\n/* they will be made accessable via EasyCanvas.hotAndReady */\n\n// tools\nfunction drawTooltip(x, y, info) {\n    let padding = 10;\n    let lineHeight = this.fontsize;\n    let letterWidth = this.fontsize / 2;\n    let keys = Object.keys(info);\n    let values = Object.values(info);\n    let labels = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.zip)(keys, values).map(pair => [`${pair[0]}: `, `${pair[1]}`]);\n    x = this.scaleX(x);\n    y = this.scaleY(y);\n    // find height and width\n    let h = labels.length * lineHeight;\n    h += padding * (labels.length + 1);\n    let w = Math.max(...labels.map(pair => pair[0].length + pair[1].length)) * letterWidth + 2 * padding;\n    // move tooltip up and left if necessary.\n    if (x + w > this.canvas.width) {\n        x = this.canvas.width - w;\n    }\n    if (y + h > this.canvas.height) {\n        y = this.canvas.height - h;\n    }\n    // Draw Rectangle \n    this.ctx.save();\n    this.ctx.fillStyle = \"rgba(255,255,255,0.75)\";\n    this.ctx.beginPath();\n    this.ctx.rect(x, y, w, h);\n    this.ctx.stroke();\n    this.ctx.fill();\n    this.ctx.restore();\n    // draw text for individual labels\n    for (let [i, label] of labels.entries()) {\n        let x1 = x + padding;\n        let y1 = y + padding * (i + 1) + lineHeight * (i + 1);\n        let labelSettings = { x: x1, y: y1, textBaseline: \"bottom\" };\n        labelSettings.text = label[0];\n        labelSettings.font = `bold ${this.fontsize}px Lato`;\n        this.drawLabel(labelSettings);\n        labelSettings.x += (letterWidth * label[0].length);\n        labelSettings.text = label[1];\n        labelSettings.font = `${this.fontsize}px Lato`;\n        this.drawLabel(labelSettings);\n    }\n}\nfunction drawLegend(labels, settings) {\n    let padding = this.fontsize / 2;\n    let lineHeight = this.fontsize;\n    let letterWidth = this.fontsize / 2;\n    let patchSize = this.fontsize * (3 / 4);\n    // Rectangle \n    let h = labels.length * lineHeight;\n    h += padding * (labels.length + 1);\n    let w = Math.max(...labels.map(v => v.text.length)) * letterWidth + 3 * padding + patchSize;\n    let x = this.canvas.width - padding - w;\n    let y = padding;\n    this.ctx.fillStyle = \"rgba(255,255,255,0.7)\";\n    this.ctx.beginPath();\n    this.ctx.rect(x, y, w, h);\n    this.ctx.stroke();\n    this.ctx.fill();\n    this.ctx.fillStyle = \"black\";\n    // Individual labels\n    for (let [i, label] of labels.entries()) {\n        // draw patch\n        this.ctx.fillStyle = label.color;\n        let x1 = x + padding;\n        let y1 = y + padding * (i + 1) + lineHeight * i;\n        this.ctx.beginPath();\n        this.ctx.rect(x1, y1, patchSize, patchSize);\n        this.ctx.stroke();\n        this.ctx.fill();\n        this.ctx.fillStyle = \"black\";\n        // draw text\n        x1 += (patchSize + padding);\n        y1 += lineHeight;\n        this.drawLabel({ text: label.text, x: x1, y: y1, font: `300 ${this.fontsize}px Lato`, textBaseline: \"bottom\" });\n    }\n}\nfunction drawLegendAxesLabelsAndTitle(settings) {\n    let title = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.defaultVal)(settings.title, \"Untitled\");\n    let xLabel = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.defaultVal)(settings.xLabel, \"x\");\n    let yLabel = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.defaultVal)(settings.yLabel, \"y\");\n    let legendLabels = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.defaultVal)(settings.legendLabels, [\"y\"]);\n    let colors = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.defaultVal)(settings.colors, _helpers__WEBPACK_IMPORTED_MODULE_0__.defaultColors);\n    // draw legend\n    legendLabels = legendLabels.map((field, i) => {\n        return { text: field, color: colors[i % colors.length] };\n    });\n    legendLabels = legendLabels.filter(x => x.text != \"\");\n    drawLegend.bind(this)(legendLabels);\n    // draw title\n    let titleX = this.canvas.width / 2;\n    let titleY = this.fontsize * 2.5;\n    this.drawLabel({ text: title, x: titleX, y: titleY, font: `300 ${this.fontsize * 2}px Lato`, textAlign: \"center\" });\n    // draw x-axis label\n    let xLabelX = this.canvas.width / 2;\n    let xLabelY = this.canvas.height - (this.fontsize);\n    this.drawLabel({ text: xLabel, x: xLabelX, y: xLabelY, font: `300 ${this.fontsize * 2}px Lato`, textAlign: \"center\" });\n    // draw y-axis label\n    let yLabelX = this.fontsize * 2;\n    let yLabelY = this.canvas.height / 2;\n    this.drawLabel({ text: yLabel, x: yLabelX, y: yLabelY, theta: Math.PI / 2, font: `300 ${this.fontsize * 2}px Lato`, textAlign: \"center\" });\n}\nfunction rescaleAxes(xmin, xmax, ymin, ymax) {\n    let ga = this.getAttribute.bind(this);\n    let sa = this.setAttribute.bind(this);\n    if (this.xmin != xmin || this.xmax != xmax || this.ymin != ymin || this.ymax != ymax) {\n        sa(\"xmin\", xmin);\n        sa(\"xmax\", xmax);\n        sa(\"ymin\", ymin);\n        sa(\"ymax\", ymax);\n    }\n}\nfunction getLinePlotTooltip(data, inputs, outputs, tooltips, epsilon = 100) {\n    // make sure inputs has exactly one unique element.\n    if (new Set(inputs).size != 1) {\n        console.log(\"in order to have tooltips on a line plot, all inputs must be the same.\");\n        return undefined;\n    }\n    let xs = data[inputs[0]];\n    // get closest point to mouse.\n    let mx = this.mouseX;\n    let my = this.mouseY;\n    // binary search over x\n    let low = 0;\n    let high = xs.length - 1;\n    let guess = Math.round((high + low) / 2);\n    while (high - low > 1) {\n        if (xs[guess] > mx) {\n            high = guess;\n        }\n        else {\n            low = guess;\n        }\n        guess = Math.round((high + low) / 2);\n    }\n    let index = low;\n    if (Math.abs(xs[high] - mx) < Math.abs(xs[low] - mx)) {\n        index = high;\n    }\n    // find closest y-coordinate\n    let output = undefined;\n    let smallestDist = Infinity;\n    for (let out of outputs) {\n        let d = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.dist)(xs[index], data[out][index], mx, my);\n        if (d < smallestDist) {\n            output = out;\n            smallestDist = d;\n        }\n    }\n    // ensure it is within epsilon of mouse in canvas (c) coordinates.\n    let cPointX = this.scaleX(xs[index]);\n    let cPointY = this.scaleY(data[output][index]);\n    let cMouseX = this.scaleX(mx);\n    let cMouseY = this.scaleY(my);\n    if ((0,_helpers__WEBPACK_IMPORTED_MODULE_0__.dist)(cPointX, cPointY, cMouseX, cMouseY) > epsilon) {\n        return undefined;\n    }\n    let x = xs[index];\n    let y = data[output][index];\n    let info = {};\n    for (let tooltip of tooltips) {\n        let text = String(data[tooltip][index]);\n        if (isNaN(text)) {\n            info[tooltip] = text.slice(0, 8) + \"...\";\n        }\n        else {\n            info[tooltip] = parseFloat(text).toFixed(3);\n        }\n    }\n    return { x: x, y: y, info: info };\n}\nfunction defaultLinePlotListener(data, inputs, outputs, tooltips) {\n    return function () {\n        let tooltip = getLinePlotTooltip.bind(this)(data, inputs, outputs, tooltips);\n        if (tooltip != undefined) {\n            this.renderPlot();\n        }\n    };\n}\n// Actual exported functions\nfunction linePlot(data, settings) {\n    let inputs = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.defaultVal)(settings.inputs, [\"xs\"]);\n    let outputs = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.defaultVal)(settings.outputs, [\"ys\"]);\n    let autoScale = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.defaultVal)(settings.autoScale, true);\n    let colors = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.defaultVal)(settings.colors, _helpers__WEBPACK_IMPORTED_MODULE_0__.defaultColors);\n    let lineWidth = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.defaultVal)(settings.lineWidth, 2);\n    let tooltips = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.defaultVal)(settings.tooltips, []);\n    let xTicks = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.defaultVal)(settings.xTicks, Math.floor(this.canvas.width / 120));\n    let yTicks = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.defaultVal)(settings.yTicks, Math.floor(this.canvas.height / 80));\n    let xAxisIsTime = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.defaultVal)(settings.xAxisIsTime, false);\n    let yAxisIsTime = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.defaultVal)(settings.yAxisIsTime, false);\n    let zipped = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.zip)(inputs, outputs);\n    // find extent of data.\n    let xmin = Infinity;\n    let ymin = Infinity;\n    let xmax = -Infinity;\n    let ymax = -Infinity;\n    for (let [i, [x, y]] of zipped.entries()) {\n        xmin = Math.min(Math.min(...data[x]), xmin);\n        xmax = Math.max(Math.max(...data[x]), xmax);\n        ymin = Math.min(Math.min(...data[y]), ymin);\n        ymax = Math.max(Math.max(...data[y]), ymax);\n    }\n    // rescale canvas if desired\n    // find a better way...\n    if (autoScale && !this.alreadyAutoScaledLinePlot) {\n        xmin = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.defaultVal)(settings.xmin, xmin);\n        xmax = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.defaultVal)(settings.xmax, xmax);\n        ymin = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.defaultVal)(settings.ymin, ymin);\n        ymax = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.defaultVal)(settings.ymax, ymax);\n        this.alreadyAutoScaledLinePlot = true;\n        rescaleAxes.bind(this)(xmin, xmax, ymin, ymax);\n    }\n    // draw lines\n    for (let [i, [x, y]] of zipped.entries()) {\n        this.ctx.strokeStyle = colors[i % colors.length];\n        let line = { xs: data[x], ys: data[y] };\n        this.drawLine(line, lineWidth);\n    }\n    this.ctx.strokeStyle = \"black\";\n    // use axes information sent to linePlot and not the default\n    // axes of easyCanvas.\n    if (this.defaultAxesOn) {\n        this.setAttribute(\"default-axes-on\", \"false\");\n    }\n    this.drawDefaultAxes({\n        xTicks: xTicks,\n        yTicks: yTicks,\n        xAxisIsTime: xAxisIsTime,\n        yAxisIsTime: yAxisIsTime\n    });\n    // legend, plot title, and axes labels.\n    drawLegendAxesLabelsAndTitle.bind(this)(settings);\n    // draw tooltips\n    if (tooltips.length != 0 && this.mouseX !== undefined) {\n        let tooltip = getLinePlotTooltip.bind(this)(data, inputs, outputs, tooltips);\n        if (tooltip != undefined) {\n            let { x, y, info } = tooltip;\n            drawTooltip.bind(this)(x, y, info);\n        }\n    }\n    if (this.hotAndReadyEventListeners[\"linePlot\"] === undefined) {\n        this.hotAndReadyEventListeners[\"linePlot\"] = {\n            mousemove: defaultLinePlotListener(data, inputs, outputs, tooltips).bind(this)\n        };\n        this.canvas.addEventListener(\"mousemove\", this.hotAndReadyEventListeners[\"linePlot\"][\"mousemove\"]);\n    }\n}\nfunction barPlot(data, settings) {\n    let autoScale = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.defaultVal)(settings.autoScale, true);\n    let colors = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.defaultVal)(settings.colors, _helpers__WEBPACK_IMPORTED_MODULE_0__.defaultColors);\n    if (autoScale) {\n        rescaleAxes.bind(this)(0, 1, 0, Math.max(...data.heights));\n    }\n    // y-axis\n    let labelXOffset = this.scaleXInverse(-this.fontsize) - this.scaleXInverse(0);\n    this.drawAxis({\n        x1: 0,\n        y1: 0,\n        x2: 0,\n        y2: this.ymax,\n        labelXOffset: labelXOffset,\n        labelYOffset: 0,\n        labelTheta: 2 * Math.PI / 5,\n        nTicks: 5,\n        labels: undefined,\n        scaleStart: 0,\n        scaleEnd: this.ymax\n    });\n    // x-axis\n    let labelYOffset = this.scaleYInverse(this.fontsize * 1.5) - this.scaleYInverse(0);\n    this.drawAxis({\n        x1: 0,\n        y1: 0,\n        x2: this.xmax,\n        y2: 0,\n        labelXOffset: 0,\n        labelYOffset: labelYOffset,\n        labelTheta: Math.PI / 15,\n        nTicks: data.bars.length + 1,\n        labels: data.bars.concat(\"\")\n    });\n    for (let i = 0; i < data.heights.length; i++) {\n        let w = 1 / (data.heights.length + 2);\n        let pos = ((i + 1) / (data.heights.length + 1)) - (w / 2);\n        this.ctx.beginPath();\n        this.ctx.fillStyle = colors[i % colors.length];\n        this.rect(pos, 0, w, data.heights[i]);\n        if (this.mouseInRect(pos, 0, pos + w, 0 + data.heights[i])) {\n            this.ctx.lineWidth = 3;\n            this.ctx.stroke();\n        }\n        this.ctx.fill();\n    }\n    this.ctx.lineWidth = 1;\n    this.ctx.fillStyle = \"black\";\n    if (this.defaultAxesOn) {\n        this.setAttribute(\"default-axes-on\", \"false\");\n    }\n    if (this.controls) {\n        this.setAttribute(\"controls\", \"false\");\n    }\n    drawLegendAxesLabelsAndTitle.bind(this)(settings);\n}\nfunction histogram(data) {\n    this.setAttribute(\"default-axes-on\", \"false\");\n}\n\n// module.exports = {\n//     \"linePlot\": linePlot,\n//     \"barPlot\": barPlot,\n//     \"histogram\": histogram,\n//     \"drawTooltip\": drawTooltip\n// }\n// module.exports = [\n//     [\"linePlot\",linePlot],\n//     [\"barPlot\", barPlot],\n//     [\"histogram\", barPlot]\n// ]; \n\n\n//# sourceURL=webpack:///./easyCanvasHotAndReady.ts?");

/***/ }),

/***/ "./helpers.ts":
/*!********************!*\
  !*** ./helpers.ts ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defaultColors: () => (/* binding */ defaultColors),\n/* harmony export */   defaultVal: () => (/* binding */ defaultVal),\n/* harmony export */   defaultVals: () => (/* binding */ defaultVals),\n/* harmony export */   dist: () => (/* binding */ dist),\n/* harmony export */   getTimeLabel: () => (/* binding */ getTimeLabel),\n/* harmony export */   zip: () => (/* binding */ zip)\n/* harmony export */ });\nlet defaultColors = [\"red\", \"green\", \"orange\", \"blue\", \"purple\", \"yellow\"];\nfunction zip(xs, ys) {\n    return xs.map((v, i) => [v, ys[i]]);\n}\nfunction defaultVal(original, def) {\n    if (original === undefined) {\n        return def;\n    }\n    return original;\n}\nfunction defaultVals(obj, keys, defs) {\n    return keys.map((k, i) => defaultVal(obj[k], defs[i]));\n}\nfunction dist(x1, y1, x2, y2) {\n    // compute pointwise distance treating x1 as one point and y1 as another.\n    // hack because js doesn't have function overloading...\n    if (x2 === undefined && y2 === undefined) {\n        return dist(x1.x, x1.y, y1.x, y1.y);\n    }\n    return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n}\nfunction getTimeLabel(i, nTicks, scaleStart, scaleEnd) {\n    let start = new Date(scaleStart);\n    let now = new Date(scaleStart + (scaleEnd - scaleStart) * (i / nTicks));\n    let end = new Date(scaleEnd);\n    let label = now.getFullYear();\n    let secondLength = 1000;\n    let minuteLength = secondLength * 60;\n    let hourLength = minuteLength * 60;\n    let dayLength = hourLength * 24;\n    let monthLength = dayLength * 30;\n    let yearLength = dayLength * 365;\n    // years\n    if (end - start > yearLength) {\n        label = `${now.getFullYear()}`;\n    }\n    // months\n    else if (end - start > monthLength) {\n        label = `${now.getMonth() + 1}/${now.getFullYear()}`;\n    }\n    // days\n    else if (end - start > dayLength) {\n        label = `${now.getMonth() + 1}/${now.getDate()}`;\n    }\n    // hours\n    else if (end - start > hourLength) {\n        label = `${now.getHours()}h:${now.getMinutes()}m`;\n    }\n    // minutes\n    else if (end - start > minuteLength) {\n        label = `${now.getMinutes()}m:${now.getSeconds()}s`;\n    }\n    // seconds\n    else if (end - start > secondLength) {\n        label = `${now.getSeconds()}s`;\n    }\n    // milliseconds\n    else {\n        label = `${now.getMilliseconds()}ms`;\n    }\n    return label;\n}\n\n// module.exports = {\n//     \"defaultColors\": defaultColors,\n//     \"zip\":zip,\n//     \"defaultVal\": defaultVal,\n//     \"defaultVals\": defaultVals,\n//     \"dist\": dist,\n//     \"getTimeLabel\": getTimeLabel\n// }\n\n\n//# sourceURL=webpack:///./helpers.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./easyCanvas.ts");
/******/ 	
/******/ })()
;